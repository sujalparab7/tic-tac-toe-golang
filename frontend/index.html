<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe (Go Backend)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Disables double-tap zoom on mobile */
        }
        .cell {
            font-family: 'Inter', sans-serif;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: 700;
            border: 2px solid #cbd5e1; /* slate-300 */
            cursor: pointer;
            transition: background-color 0.2s;
            -webkit-tap-highlight-color: transparent; /* Removes blue tap highlight on mobile */
        }
        
        /* Responsive cell sizing for larger boards */
        [data-board-size="4"] .cell {
            width: 80px;
            height: 80px;
            font-size: 2.5rem;
        }
        [data-board-size="5"] .cell {
            width: 65px;
            height: 65px;
            font-size: 2rem;
        }

        .cell:hover:not(.occupied) {
            background-color: #f1f5f9; /* slate-100 */
        }
        .cell.occupied {
            cursor: not-allowed;
        }
        .text-playerX { color: #2563eb; } /* blue-600 */
        .text-playerO { color: #dc2626; } /* red-600 */
        .win-cell {
            background-color: #a7f3d0 !important; /* green-200 */
        }
        
        /* Spinner for loading */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 sm:p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-3xl sm:text-4xl font-bold text-center mb-4">Tic-Tac-Toe</h1>
        
        <!-- Game Controls -->
        <div class="flex justify-between items-center mb-4 space-x-2">
            <div class="flex-1">
                <label for="boardSize" class="block text-sm font-medium text-slate-600 mb-1">Board Size</label>
                <select id="boardSize" class="w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    <option value="3" selected>3x3 (Unbeatable AI)</option>
                    <option value="4">4x4 (Strong AI)</option>
                    <option value="5">5x5 (Strong AI)</option>
                </select>
            </div>
            <div class="pt-5">
                <button id="resetButton" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-blue-700 active:bg-blue-800 transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Reset
                </button>
            </div>
        </div>

        <!-- Game Status Message -->
        <div id="message" class="text-center text-lg font-medium text-slate-700 h-6 mb-4 flex justify-center items-center">
            &nbsp; <!-- Placeholder for message -->
        </div>

        <!-- Game Board -->
        <div id="board-container" class="flex justify-center">
            <div id="board" class="grid bg-white rounded-lg shadow-inner border border-slate-300">
                <!-- Cells will be generated by JS -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('board');
            const messageElement = document.getElementById('message');
            const resetButton = document.getElementById('resetButton');
            const boardSizeSelect = document.getElementById('boardSize');

            const backendUrl = 'http://localhost:8080/play';
            const player = 'X';
            const ai = 'O';

            let boardSize = 3;
            let board = [];
            let isPlayerTurn = true;
            let isGameOver = false;

            // --- Game Initialization ---

            function initializeGame() {
                boardSize = parseInt(boardSizeSelect.value, 10);
                board = Array(boardSize * boardSize).fill(""); // Use "" for empty to match Go backend
                isPlayerTurn = true;
                isGameOver = false;
                
                // Update container for responsive cell sizing
                const boardContainer = document.getElementById('board-container');
                boardContainer.dataset.boardSize = boardSize;

                // Create grid
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;

                for (let i = 0; i < boardSize * boardSize; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.index = i;
                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
                
                // Adjust cell border logic for N x N
                const cells = document.querySelectorAll('.cell');
                cells.forEach((cell, i) => {
                    const r = Math.floor(i / boardSize);
                    const c = i % boardSize;
                    
                    cell.style.borderLeft = (c === 0) ? 'none' : '';
                    cell.style.borderRight = (c === boardSize - 1) ? 'none' : '';
                    cell.style.borderTop = (r === 0) ? 'none' : '';
                    cell.style.borderBottom = (r === boardSize - 1) ? 'none' : '';
                });

                setMessage("Your turn (X)");
            }

            // --- Event Handlers ---

            async function handleCellClick(e) {
                if (isGameOver || !isPlayerTurn) return;

                const index = parseInt(e.target.dataset.index, 10);
                if (board[index] !== "") return; // Cell already occupied

                // --- Player's Move ---
                board[index] = player;
                renderBoard();
                isPlayerTurn = false;
                isGameOver = checkLocalWin(player); // Check if player won on this move
                
                if (isGameOver) {
                    endGame(player);
                    return;
                }
                
                if (board.every(cell => cell !== "")) {
                    endGame("draw");
                    return;
                }

                setMessage("AI is thinking...");
                
                // --- AI's Move (via Backend) ---
                try {
                    const payload = {
                        board: board,
                        boardSize: boardSize,
                        winner: ""
                    };

                    const response = await fetch(backendUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const newState = await response.json();
                    
                    board = newState.board;
                    renderBoard();

                    if (newState.winner) {
                        endGame(newState.winner);
                    } else {
                        isPlayerTurn = true;
                        setMessage("Your turn (X)");
                    }

                } catch (error) {
                    console.error("Error connecting to backend:", error);
                    setMessage("Error: Can't connect to server.");
                    // Revert move and allow player to try again
                    // board[index] = ""; 
                    // renderBoard();
                    isPlayerTurn = true;
                }
            }

            resetButton.addEventListener('click', initializeGame);
            boardSizeSelect.addEventListener('change', initializeGame);

            // --- UI & State Functions ---

            function renderBoard() {
                for (let i = 0; i < board.length; i++) {
                    const cell = boardElement.children[i];
                    cell.textContent = board[i];
                    cell.classList.remove('text-playerX', 'text-playerO', 'occupied');
                    
                    if (board[i] === player) {
                        cell.classList.add('text-playerX', 'occupied');
                    } else if (board[i] === ai) {
                        cell.classList.add('text-playerO', 'occupied');
                    }
                }
            }
            
            function setMessage(text) {
                if (text === "AI is thinking...") {
                    messageElement.innerHTML = '<div class="spinner"></div>';
                } else {
                    messageElement.textContent = text;
                }
            }

            // This local check is just to end the game immediately on a player's winning move.
            // The backend does the definitive check.
            function checkLocalWin(p) {
                const n = boardSize;
                // Check rows
                for (let r = 0; r < n; r++) {
                    let match = true;
                    for (let c = 0; c < n; c++) if (board[r * n + c] !== p) match = false;
                    if (match) return true;
                }
                // Check cols
                for (let c = 0; c < n; c++) {
                    let match = true;
                    for (let r = 0; r < n; r++) if (board[r * n + c] !== p) match = false;
                    if (match) return true;
                }
                // Check diags
                let match1 = true;
                let match2 = true;
                for (let i = 0; i < n; i++) {
                    if (board[i * n + i] !== p) match1 = false;
                    if (board[i * n + (n - 1 - i)] !== p) match2 = false;
                }
                return match1 || match2;
            }

            function endGame(winner) {
                isGameOver = true;
                if (winner === "draw") {
                    setMessage("It's a draw!");
                } else {
                    setMessage(`${winner === player ? 'You' : 'AI'} win${winner === player ? '' : 's'}!`);
                    // Note: Highlighting winning line is harder as backend doesn't send it.
                }
            }

            // Start the game on load
            initializeGame();
        });
    </script>
</body>
</html>
